#memo


首先吧，比如说在React组件中存在一个State，状态为1，当进行一系列事件后，状态更新为了2，那么重新渲染组件，没什么问题，但是，如果经历了一系列事件后，组件的状态还是1，就相当于一开始state=1，但是处理了setstate=1，此时，到底应不应该重新渲染组件呢？当然，从性能方面考虑，既然状态没有变化，那就不应该渲染，但是，事与愿违，计算机不认识，所以，默认情况下同样会重新渲染组件，这就带来了性能无效消耗的问题，为了提高性能，我们接下来将介绍如何解决这个问题。

众所周知对于React组件，分为类组件和函数式组件。由于两种组件的书写方式有较大区别，所以，针对两种组件，各有一套方法来解决。

##类组件

首先对于类组件的渲染过程，本质就是触发了组件的生命周期，所以，对于我们只需要控制好组件的生命周期的某一步不被触发，原则上来说，就可以避免组件的重新渲染。对于类组件的生命周期中存在shouldComponentUpdate（），意为判断组件是否应该更新，这返回一个布尔型的返回值，所以，我们可以在这里添加相应的逻辑进行处理。

###纯组件
 
 React的开发者们也意识到了这个问题，所以在v15.5中，引入了纯组件的概念。
 纯组件，Pure Components，启用了默认值的相等性检查，至此，我们无须在shouldCompontentUpdate中判断，只需要继承React.PureComponents，React将自行判断是否需要进行渲染。

 ###### 注意：

 > 1.继承React.PureCompontent时，不能再充血shouldComponents=Update，否则会引发警告。
 > 2.继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致。
 > 3.浅比较会忽略属性或状态突变的情况，其实也就是，数据引用指针没变而数据被改变的时候，也不新渲染组件。但其实很大程度上，我们是希望重新渲染的。所以，这就需要开发者自己保证避免数据突变。


##函数组件

接下来是重中之重，因为在平时开发过程中我们将大量的使用函数式组件，因此针对函数式组件的优化方式尤为重要。

本片文章的标题是memo，至此我们还从未提及过我们的标题，所以，函数式组件将使用memo达到相同的处理效果。

关于React.memo的使用方式也十分简单。
只需要将进行判断的函数组件包裹在memo中便可，接下来请看示例：


```javascript
const Funcomponent = ()=> {
    return (
        <div>
            Hiya!! I am a Funtional component
        </div>
    )
}
const MemodFuncComponent = React.memo(Funcomponent)
```


React.memo 会返回了一个纯组件 MemodFuncComponent。 我们将在 JSX 标记中渲染此组件。 每当组件中的 props 和 state 发生变化时，React 将检查 上一个 state 和 props 以及下一个 props 和 state 是否相等，如果不相等则函数组件将重新渲染，如果它们相等则函数组件将不会重新渲染。

文章参考：https://segmentfault.com/a/1190000018444604
